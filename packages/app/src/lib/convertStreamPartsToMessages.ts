import type {
  CoreAssistantMessage,
  CoreToolMessage,
  TextStreamPart,
  ToolCallUnion,
  ToolResultUnion,
} from "ai";

/**
A message that was generated during the generation process.
It can be either an assistant message or a tool message.
 */
export type ResponseMessage = (CoreAssistantMessage | CoreToolMessage) & {
  /**
Message ID generated by the AI SDK.
   */
  id: string;
  streaming?: boolean;
};

export function convertStreamPartsToMessages<TOOLS extends Record<string, any>>(
  streamParts: TextStreamPart<TOOLS>[],
  generateMessageId: () => string = () =>
    Math.random().toString(36).substring(2, 9)
): ResponseMessage[] {
  const messages: ResponseMessage[] = [];

  // Track accumulated content per step
  let currentText = "";
  let currentReasoning = "";
  let currentToolCalls: ToolCallUnion<TOOLS>[] = [];
  let currentToolResults: ToolResultUnion<TOOLS>[] = [];
  let currentFiles: any[] = [];
  let currentMessageId = generateMessageId();

  function flush(finish: boolean) {
    // End of step - create message(s)
    const content = [];

    // Add reasoning if present
    if (currentReasoning.length > 0) {
      content.push({
        type: "reasoning" as const,
        text: currentReasoning,
      });
    }

    // Add files if present
    if (currentFiles.length > 0) {
      content.push(
        ...currentFiles.map((file) => ({
          type: "file" as const,
          data: file.base64,
          mimeType: file.mimeType,
        }))
      );
    }

    // Add text if present
    if (currentText.length > 0) {
      content.push({
        type: "text" as const,
        text: currentText,
      });
    }

    // Add tool calls if present
    if (currentToolCalls.length > 0) {
      content.push(...currentToolCalls);
    }

    // Create assistant message if there's content
    if (content.length > 0) {
      messages.push({
        role: "assistant",
        content,
        id: currentMessageId,
        streaming: !finish,
      });
    }

    // Create tool message if there are tool results
    if (currentToolResults.length > 0) {
      messages.push({
        role: "tool",
        id: generateMessageId(),
        content: currentToolResults.map((toolResult) => ({
          type: "tool-result" as const,
          toolCallId: toolResult.toolCallId,
          toolName: toolResult.toolName,
          result: toolResult.result,
        })),
        streaming: !finish,
      });
    }

    currentText = "";
    currentReasoning = "";
    currentToolCalls = [];
    currentToolResults = [];
    currentFiles = [];
  }

  // Process each stream part
  for (const part of streamParts) {
    switch (part.type) {
      case "text-delta":
        currentText += part.textDelta;
        break;

      case "reasoning":
        currentReasoning += part.textDelta;
        break;

      case "tool-call":
        currentToolCalls.push(part);
        break;

      case "tool-result":
        currentToolResults.push(part);
        break;

      case "file":
        currentFiles.push(part);
        break;

      case "step-start":
        currentMessageId = part.messageId;
      case "step-finish":
      case "finish":
        flush(true);
        break;
    }
  }

  flush(false);

  return messages;
}
